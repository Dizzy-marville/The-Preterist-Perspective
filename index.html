// === Initialization ===
function initializeParticles(count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      position: randomWithinCanvas(),
      velocity: randomSmallVector(),
      lifespan: randomDuration(),
      color: baseAmbientHue(),
      opacity: 1
    });
  }
}

// === Frame Update ===
function updateParticles(mousePos, time) {
  for (let p of particles) {
    // --- Flow Field Influence ---
    let flowVector = calculateFlow(mousePos, p.position);
    p.velocity = add(p.velocity, scale(flowVector, 0.05));

    // --- Pull Logic (gentle orbit) ---
    let pull = subtract(mousePos, p.position);
    p.velocity = add(p.velocity, scale(pull, 0.02));

    // --- Time-Based Drift (ritual breath) ---
    let drift = {
      x: Math.sin(time + p.position.x * 0.01),
      y: Math.cos(time + p.position.y * 0.01)
    };
    p.velocity = add(p.velocity, scale(drift, 0.01));

    // --- Motion Update ---
    p.position = add(p.position, p.velocity);
    p.velocity = scale(p.velocity, 0.95); // damping for silence

    // --- Visual Consequence ---
    p.color = updateColorByZone(p.position, mousePos);
    p.opacity = fadeByLifespan(p.lifespan);

    // --- Ritual Reset ---
    p.lifespan -= 1;
    if (p.lifespan <= 0) {
      resetParticle(p);
    }
  }
}

// === Flow Field Calculation ===
function calculateFlow(center, pos) {
  let direction = normalize(subtract(pos, center));
  let perpendicular = { x: -direction.y, y: direction.x };
  return scale(perpendicular, Math.sin(distance(center, pos) * 0.1));
}

// === Color Zones ===
function updateColorByZone(pos, center) {
  let d = distance(pos, center);
  if (d < 50) return "rgba(255, 255, 200, 0.8)";       // pale glow
  else if (d < 150) return "rgba(200, 180, 255, 0.6)";  // soft hue
  else return "rgba(100, 100, 150, 0.4)";               // fading ember
}

// === Particle Reset ===
function resetParticle(p) {
  p.position = randomEdge();
  p.velocity = randomSmallVector();
  p.lifespan = randomDuration();
  p.opacity = 1;
}
