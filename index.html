<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Modular Ritual Engine</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
</head>
<body>
  <script>
    let scene, camera, renderer, particles, geometry, material;
    let particleCount = 1000;
    let positions, velocities;
    let mouse = new THREE.Vector3();

    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 15;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.addEventListener('mousemove', onMouseMove);
    }

    function createParticles(texture) {
      positions = new Float32Array(particleCount * 3);
      velocities = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const ix = i * 3;
        const r = Math.random() * 5;
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[ix] = r * Math.sin(phi) * Math.cos(theta);
        positions[ix + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[ix + 2] = r * Math.cos(phi);

        velocities[ix] = (Math.random() - 0.5) * 0.01;
        velocities[ix + 1] = (Math.random() - 0.5) * 0.01;
        velocities[ix + 2] = (Math.random() - 0.5) * 0.01;
      }

      geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      material = new THREE.PointsMaterial({
        map: texture,
        size: 0.3,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function updateParticles() {
      const posArray = geometry.attributes.position.array;

      for (let i = 0; i < particleCount; i++) {
        const ix = i * 3;

        // Orbital drift
        const dx = -posArray[ix + 1];
        const dy = posArray[ix];
        const dz = (Math.random() - 0.5) * 0.01;

        posArray[ix] += dx * 0.001 + (mouse.x - posArray[ix]) * 0.0002;
        posArray[ix + 1] += dy * 0.001 + (mouse.y - posArray[ix + 1]) * 0.0002;
        posArray[ix + 2] += dz;
      }

      geometry.attributes.position.needsUpdate = true;
    }

    function onMouseMove(e) {
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = -(e.clientY / window.innerHeight) * 2 + 1;
      mouse.set(x, y, 0.5).unproject(camera);
    }

    function animate() {
      requestAnimationFrame(animate);
      updateParticles();
      renderer.render(scene, camera);
    }

    function startRitual() {
      initScene();

      const loader = new THREE.TextureLoader();
      loader.load(
        'https://threejs.org/examples/textures/sprites/circle.png',
        texture => {
          createParticles(texture);
          animate();
        },
        undefined,
        err => console.error('Texture load failed:', err)
      );
    }

    startRitual();
  </script>
</body>
</html>
